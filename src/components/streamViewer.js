import {
  Button,
  CircularProgress,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
  Grid,
  InputAdornment,
  Modal,
  TextField,
  Tooltip,
  Typography,
  withStyles,
} from "@material-ui/core";
import { Send as SendIcon, Link as LinkIcon } from "@material-ui/icons";
import { Zero } from 'ethers/constants';
import QRIcon from "mdi-material-ui/QrcodeScan";
import React, { Component } from "react";
import queryString from "query-string";

import { Currency, toBN, toWei } from "../utils";

import { QRScan } from "./qrCode";

const LINK_LIMIT = Currency.DAI("10") // $10 capped linked payments

const styles = theme => ({
  icon: {
    width: "40px",
    height: "40px"
  },
  input: {
    width: "100%"
  },
  button: {
    backgroundColor: "#FCA311",
    color: "#FFF"
  },
  streamIframe: {
    width: "calc(100vw - 24px)",
    height: "calc(46vw - 13.5px)",
    maxWidth: "442px",
    maxHeight: "248.6px"
  },
});

const PaymentStates = {
  None: 0,
  Collateralizing: 1,
  CollateralTimeout: 2,
  OtherError: 3,
  Success: 4
};

class StreamViewer extends Component {
  constructor(props) {
    super(props);
    this.state = {
      amount: { display: "", error: null, value: null },
      recipient: { display: "", error: null, value: null },
      sendError: null,
      scan: false,
      showReceipt: false,
      paymentState: PaymentStates.None,
    };
  }

  async componentDidMount() {
    const query = queryString.parse(this.props.location.search);
    if (query.amountToken) { this.updateAmountHandler(query.amountToken) }
    if (query.recipient) { this.updateRecipientHandler(query.recipient) }
  }

  handleQRData = async scanResult => {
    let data = scanResult.split("/send?");
    if (data[0] === window.location.origin) {
      const query = queryString.parse(data[1]);
      if (query.amountToken) { this.updateAmountHandler(query.amountToken) }
      if (query.recipient) { this.updateRecipientHandler(query.recipient) }
    } else {
      console.warn(`QR Code was generated by incorrect site: ${data[0]}`);
    }
    this.setState({ scan: false });
  };

  async updateAmountHandler(rawValue) {
    const { balance } = this.props
    let value = null, error = null
    try {
      value = Currency.DAI(rawValue)
    } catch (e) {
      error = e.message
    }
    if (value && value.wad.gt(balance.channel.token.wad)) {
      error = `Invalid amount: must be less than your balance`
    }
    if (value && value.wad.lte(Zero)) {
      error = "Invalid amount: must be greater than 0"
    }
    this.setState({
      amount: {
        display: rawValue,
        error,
        value: error ? null : value,
      }
    })
  }

  async updateRecipientHandler(rawValue) {
    const xpubLen = 111
    let value = null, error = null
    value = rawValue
    if (!value.startsWith('xpub')) {
      error = "Invalid recipient: should start with xpub"
    }
    if (!error && value.length !== xpubLen) {
      error = `Invalid recipient: expected ${xpubLen} characters, got ${value.length}`
    }
    this.setState({
      recipient: {
        display: rawValue,
        error,
        value: error ? null : value,
      }
    })
  }

  async paymentHandler() {
    const { channel, token } = this.props;
    const { amount, recipient } = this.state;
    if (amount.error || recipient.error) return;
    // TODO: check if recipient needs collateral & tell server to collateralize if more is needed
    try {
      console.log(`Sending ${amount.value} to ${recipient.value}`);
      await channel.transfer({
        assetId: token.address,
        amount: amount.value.toDEI().floor(),
        recipient: recipient.value,
      });
      this.setState({ showReceipt: true, paymentState: PaymentStates.Success });
    } catch (e) {
      console.error(`Unexpected error sending payment: ${e.message}`);
      console.error(e)
      this.setState({ paymentState: PaymentStates.OtherError, showReceipt: true });
    }
  }

  async linkHandler() {
    const { channel, token } = this.props;
    const { amount, recipient } = this.state;
    if (amount.error || recipient.error) return;
    if (toBN(amount.value.toDAI().wad).gt(LINK_LIMIT.wad)) {
      this.setState(oldState => {
        oldState.amount.error = `Linked payments are capped at ${LINK_LIMIT.format()}.`
        return oldState
      })
      return
    }
    try {
      console.log(`Creating ${amount.value} link payment`);
      const link = await channel.conditionalTransfer({
        assetId: token.address,
        amount: amount.value.toDEI().floor(),
        conditionType: "LINKED_TRANSFER",
      });
      console.log(`Created link payment: ${JSON.stringify(link, null, 2)}`);
      console.log(`link params: secret=${link.preImage}&paymentId=${link.paymentId}&` +
          `assetId=${token.address}&amount=${amount.value.amount}`)
      this.props.history.push({
        pathname: "/redeem",
        search: `?secret=${link.preImage}&paymentId=${link.paymentId}&` +
          `assetId=${token.address}&amount=${amount.value.amount}`,
        state: { isConfirm: true, secret: link.preImage, amountToken: amount.value.amount },
      });
    } catch (e) {
      console.log("Unexpected error sending payment:", e);
      this.setState({ paymentState: PaymentStates.OtherError, showReceipt: true });
    }
  }

  closeModal = () => {
    this.setState({ showReceipt: false, paymentState: PaymentStates.None });
  };





  render() {
    const { connextState, classes, dTokStreams } = this.props;
    const { scan, amount, recipient, paymentState, paymentVal, showReceipt, sendError, streamViewingEnabled, currentStreamKey } = this.state;

    if (Object.keys(dTokStreams.streams).length < 1 || currentStreamKey === null) {
      return <div>No streams avaliable...</div>;
    }

    return (
      <Grid
        container
        spacing={16}
        direction="column"
        style={{
          display: "flex",
          paddingLeft: 12,
          paddingRight: 12,
          paddingTop: "10%",
          paddingBottom: "10%",
          textAlign: "center",
          justify: "center"
        }}
      >
        <Grid item xs={12}>
          <Select
            fullWidth
            value={currentStreamKey}
            onChange={e => this.setState({ currentStreamKey: e.target.value })}
            style={{
              border: "1px solid #3CB8F2",
              color: "#3CB8F2",
              textAlign: "center",
              borderRadius: "4px",
              height: "45px"
            }}
            disableUnderline
            IconComponent={() => null}
          >
            {Object.keys(dTokStreams.streams).map(streamKey => (
              <MenuItem value={streamKey} key={streamKey}>{dTokStreams.streams[streamKey].value.title}</MenuItem>
            ))}
          </Select>
        </Grid>
        <Grid
          container
          wrap="nowrap"
          direction="row"
          justify="center"
          alignItems="center"
        >
          <Grid item xs={12}>
            {(streamViewingEnabled && parseInt(getOwedBalanceInDAI(connextState, false)) > 0) &&
              <iframe title="stream" className={classes.streamIframe} src="http://media.livepeer.org/embed?aspectRatio=16%3A9&maxWidth=100%25&url=http%3A%2F%2Fd7eb1baa.ngrok.io%2Fstream%2Fa24de3ee390b3ddfc73882f4372fa86316bc484a69ae9dbe7b1bb9bad6502de7P720p30fps16x9.m3u8" allowFullScreen></iframe>
            }
            {((!streamViewingEnabled) && parseInt(getOwedBalanceInDAI(connextState, false)) > 0) &&
              <div className={classes.streamBlocker}>
                <div className={classes.streamBlockerTextSpacer} />
                <div className={classes.streamBlockerText}>
                  <div className={classes.streamBlockerTextInner}>
                    You must enable the stream below to watch. <span role="img" aria-label="">ðŸ™ˆ</span>
                  </div>
                </div>
              </div>
            }
            {(parseInt(getOwedBalanceInDAI(connextState, false)) <= 0) &&
              <div className={classes.streamBlocker}>
                <div className={classes.streamBlockerTextSpacer} />
                <div className={classes.streamBlockerText}>
                  <div className={classes.streamBlockerTextInner}>
                    Your balance is empty! <span role="img" aria-label="">ðŸ˜²</span>
                  </div>
                </div>
              </div>
            }
          </Grid>
        </Grid>
        <Grid item xs={12}>
          <Grid container direction="row" justify="center" alignItems="center">
            <Typography variant="h2">
              <span>
                {getOwedBalanceInDAI(connextState, false)}
              </span>
            </Typography>
          </Grid>
        </Grid>
        <Grid item xs={12}>
          <Typography variant="body2">
            {(parseInt(getOwedBalanceInDAI(connextState, false)) <= 0) &&
              <span>
                Please click the button below to deposit DAI for viewing the stream.
              </span>
            }
            {(parseInt(getOwedBalanceInDAI(connextState, false)) > 0) &&
              <span>
                Viewing the stream (by clicking "Start Stream" below) will cost $0.02 per minute.
              </span>
            }
          </Typography>
        </Grid>
        <Grid item xs={12}>
          <Button
            fullWidth
            style={{
              color: "#FFF",
              backgroundColor: "#FCA311"
            }}
            size="large"
            variant="contained"
            onClick={() => 
              // Only enable viewing of the stream if the user has a non-zero balance.
              (parseInt(getOwedBalanceInDAI(connextState, false)) > 0) && this.setState({ streamViewingEnabled: !streamViewingEnabled })
            }
            {...( // We only want the button to function as a link to the /deposit page if the DAI balance is currently empty.
              (parseInt(getOwedBalanceInDAI(connextState, false)) <= 0) ?
                {
                  to: "/deposit",
                  component: Link
                }
              :
                {}
            )}
          >
            {(parseInt(getOwedBalanceInDAI(connextState, false)) <= 0) &&
              "Deposit DAI to View Stream"
            }
            {(parseInt(getOwedBalanceInDAI(connextState, false)) > 0) && (!streamViewingEnabled) &&
              "Start Stream"
            }
            {(parseInt(getOwedBalanceInDAI(connextState, false)) > 0) && streamViewingEnabled &&
              "Stop Stream"
            }
            {(parseInt(getOwedBalanceInDAI(connextState, false)) > 0) &&
              <RemoveRedEye style={{ marginLeft: "5px" }} />
            }
            {(parseInt(getOwedBalanceInDAI(connextState, false)) <= 0) &&
              <Block style={{ marginLeft: "5px" }} />
            }
          </Button>
        </Grid>
        <Grid item xs={12}>
          <Button
            variant="outlined"
            style={{
              background: "#FFF",
              border: "1px solid #F22424",
              color: "#F22424",
              width: "15%"
            }}
            size="medium"
            onClick={() => this.props.history.push("/")}
          >
            Back
          </Button>
        </Grid>
        {/* We only show the PaymentConfirmationDialog if there was some kind of issue / error processing the payment. */}
        <PaymentConfirmationDialog
          showReceipt={showReceipt && (paymentState !== PaymentStates.Success)}
          sendError={sendError}
          amountToken={
            paymentVal.payments[0].amountToken
              ? Web3.utils.fromWei(
                  paymentVal.payments[0].amountToken
                )
              : "0"
          }
          recipient={paymentVal.payments[0].recipient}
          history={this.props.history}
          closeModal={this.closeModal}
          paymentState={paymentState}
        />
        {/* We show the MySnackbar component if the payment was successful. */}
        <MySnackbar
          variant="success"
          openWhen={showReceipt && (paymentState === PaymentStates.Success)}
          onClose={() => this.closeModal()}
          message="Successfully paid $0.02 for another minute of viewing! ðŸ‘€"
          duration={5000}
        />
      </Grid>
    );
  }
}

function ConfirmationDialogText(paymentState, amountToken, recipient) {
  switch (paymentState) {
    case PaymentStates.Collateralizing:
      return (
        <Grid>
          <DialogTitle disableTypography>
            <Typography variant="h5" color="primary">
              Payment In Progress
            </Typography>
          </DialogTitle>
          <DialogContent>
            <DialogContentText variant="body1" style={{ color: "#0F1012", margin: "1em" }}>
              Recipient's Card is being set up. This should take 20-30 seconds.
            </DialogContentText>
            <DialogContentText variant="body1" style={{ color: "#0F1012" }}>
              If you stay on this page, your payment will be retried automatically.
              If you navigate away or refresh the page, you will have to attempt the payment again yourself.
            </DialogContentText>
          <CircularProgress style={{ marginTop: "1em" }} />
          </DialogContent>
        </Grid>
      );
    case PaymentStates.CollateralTimeout:
      return (
        <Grid>
          <DialogTitle disableTypography>
            <Typography variant="h5" style={{ color: "#F22424" }}>
            Payment Failed
            </Typography>
          </DialogTitle>
          <DialogContent>
            <DialogContentText variant="body1" style={{ color: "#0F1012", margin: "1em" }}>
            After some time, recipient channel could not be initialized.
            </DialogContentText>
            <DialogContentText variant="body1" style={{ color: "#0F1012" }}>
            Is the receiver online to set up their Card? Please try your payment again later. If
              you have any questions, please contact support. (Settings -->
              Support)
            </DialogContentText>
          </DialogContent>
        </Grid>
      );
    case PaymentStates.OtherError:
      return (
        <Grid>
          <DialogTitle disableTypography>
            <Typography variant="h5" style={{ color: "#F22424" }}>
            Payment Failed
            </Typography>
          </DialogTitle>
          <DialogContent>
            <DialogContentText variant="body1" style={{ color: "#0F1012", margin: "1em" }}>
            An unknown error occured when making your payment.
            </DialogContentText>
            <DialogContentText variant="body1" style={{ color: "#0F1012" }}>
            Please try again in 30s and contact support if you continue to
              experience issues. (Settings --> Support)
            </DialogContentText>
          </DialogContent>
        </Grid>
      );
    case PaymentStates.Success:
      return (
        <Grid>
          <DialogTitle disableTypography>
            <Typography variant="h5" style={{ color: "#009247" }}>
            Payment Success!
            </Typography>
          </DialogTitle>
          <DialogContent>
            <DialogContentText variant="body1" style={{ color: "#0F1012", margin: "1em" }}>
            Amount: ${amountToken}
            </DialogContentText>
            <DialogContentText variant="body1" style={{ color: "#0F1012" }}>
            To: {recipient.substr(0, 5)}...
            </DialogContentText>
          </DialogContent>
        </Grid>
      );
    case PaymentStates.None:
    default:
      return <div />;
  }
}

function PaymentConfirmationDialog(props) {
  return (
    <Dialog
      open={props.showReceipt}
      onBackdropClick={
        props.paymentState === PaymentStates.Collateralizing
          ? null
          : () => props.closeModal()
      }
      fullWidth
      style={{
        justifyContent: "center",
        alignItems: "center",
        textAlign: "center",
      }}
    >
      <Grid
        container
        style={{
          backgroundColor: "#FFF",
          paddingTop: "10%",
          paddingBottom: "10%"
        }}
        justify="center"
      >
        {ConfirmationDialogText(
          props.paymentState,
          props.amountToken,
          props.recipient
        )}
        {props.paymentState === PaymentStates.Collateralizing ? (
          <></>
        ) : (
          <DialogActions>
            <Button
              color="primary"
              variant="outlined"
              size="medium"
              onClick={() => props.closeModal()}
            >
              Pay Again
            </Button>
            <Button
              style={{
                background: "#FFF",
                border: "1px solid #F22424",
                color: "#F22424",
                marginLeft: "5%"
              }}
              variant="outlined"
              size="medium"
              onClick={() => props.history.push("/")}
            >
              Home
            </Button>
          </DialogActions>
        )}
      </Grid>
    </Dialog>
  );
};

export default withStyles(styles)(StreamViewer);
